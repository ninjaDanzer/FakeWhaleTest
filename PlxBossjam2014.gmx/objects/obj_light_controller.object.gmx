<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init lighting engine.

randomize();
/*
This is where things start. ls_system_properties sets up the engine.
You can toggle the whole system on and off with this function, as well
as set the drawing mode, color of the "darkness" and whether or not to
cover all shadow casters with darkness.
*/
ls_system_properties(true, ls_dm_normal, c_black, true);

/*
When rendering lights, the system needs to know what views you want to use.
In this case, we don't use views, so we need to tell it that we don't have
any. 
*/
ls_view_attach(0);

/*
Here we create our first light on the mouse. The light radius is how far the
light casts away from the core. The core-radius is how big the actual "object"
casting the light is. 

Spread is how many degrees the light should cover around the center, and
precision is how many points should be used to define the light's shape.
*/
playerlight = ls_light_create(mouse_x, mouse_y, 320, 360, 0, c_white, 32, false, true, 16);

with (parent_light_block) {
    /*First we must create an empty shadow shape for the block,
      and say which way we will be defining the points.*/
    myshadow = ls_shadow_create(ls_ss_cw);
    
    /*Now we can actually add points to the shape.
      Subdivision will subdivide if the length is over
      the value specified. This helps with shadow artifacts
      if the shadows are too long, or the lights too small.*/
    var sW,sH;
    sW = sprite_width;
    sH = sprite_height;
    ls_shadow_addpoint_cartesian(myshadow, 0, 0, 128);
    ls_shadow_addpoint_cartesian(myshadow, sW, 0, 128);
    ls_shadow_addpoint_cartesian(myshadow, sW, sH, 128);
    ls_shadow_addpoint_cartesian(myshadow, 0, sH, 128);
    
    /*This last point that closes the shape is not needed. If you do not place
      it, the engine will place it for you. However, the engine does not use
      subdivision, which is what we want here, so we place it manually.*/
    ls_shadow_addpoint_cartesian(myshadow, 0, 0, 128);
    
    /*Now that we are done adding the points, we need to add the shape to the room!*/
    ls_shadow_attach_pos(myshadow, x, y, true);
    
    /*Note: In this engine we make a custom shape for every single object. You don't 
      have to do this, and in fact it is better if you don't. It is best to use the
      same shadow shape in multiple places if possible. However, since all these
      squares can be any size, we need to create a custom one for each.*/
}

/*
It is possible to have animated shadows  for when you have morphing objects. In this
case you can either clear all the points and redefine them, or you can manually modify
each point.

ls_shadow_addpoint_* functions return an array of points. The first entry in the point
will hold the number of points in the array. The following values will be the positions
of the shadow points in shadow shape. 

There will only be more than 1 point if subdivision is enabled, and the shape is 
longer than the subdivision value.
*/
shadowcaps = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update light properties.
/*
Updating light properties is as simple as calling the correct function
and passing the light ID to it.
*/
ls_light_set_pos(playerlight, obj_player.x, obj_player.y - 50);

ls_light_set_visible(playerlight, obj_player.image_alpha &gt; 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Render light engine.
/*
This function actually draws the system on the screen.
The first argument determines if you want the system to update or not,
and the second will toggle debug mode.
*/
ls_system_draw(true, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
